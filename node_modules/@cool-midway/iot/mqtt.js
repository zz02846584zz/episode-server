"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoolMqttServe = void 0;
const core_1 = require("@midwayjs/core");
const mqtt_1 = require("./decorator/mqtt");
const crypto_1 = require("crypto");
/**
 * MQTT服务
 */
let CoolMqttServe = class CoolMqttServe {
    async init() {
        await this.initServe();
        await this.handlerCls();
        await this.startServe();
    }
    /**
     * 开启服务
     */
    async startServe() {
        const { port, wsPort } = this.coolIotConfig;
        const { createServer } = require('aedes-server-factory');
        const server = createServer(this.serve);
        const serverWs = createServer(this.serve, { ws: true });
        server.listen(port, () => {
            this.coreLogger.info(`\x1B[36m [cool:iot] MQTT serve started port: ${port} \x1B[0m`);
        });
        serverWs.listen(wsPort, () => {
            this.coreLogger.info(`\x1B[36m [cool:iot] MQTT websocket serve started port: ${wsPort} \x1B[0m`);
        });
    }
    /**
     * 初始化服务
     */
    async initServe() {
        const { redis } = this.coolIotConfig;
        let option = {};
        // cluster模式下必须配置redis
        if (redis) {
            const mqredis = require('@cool-midway/mqemitter-redis');
            const mq = mqredis(redis);
            option.id = (0, crypto_1.randomUUID)();
            // redis cluster模式
            if (redis instanceof Array) {
                option.persistence = require('aedes-persistence-redis')({
                    cluster: redis,
                    maxSessionDelivery: 1000, // maximum offline messages deliverable on client CONNECT, default is 1000
                });
            }
            else {
                option.persistence = require('aedes-persistence-redis')({
                    ...redis,
                    maxSessionDelivery: 1000, // maximum offline messages deliverable on client CONNECT, default is 1000
                });
            }
            option = {
                id: (0, crypto_1.randomUUID)(),
                mq,
            };
        }
        this.serve = require('aedes')(option);
        // 认证
        if (this.coolIotConfig.auth) {
            const auth = this.coolIotConfig.auth;
            this.serve.authenticate = function (client, username, password, callback) {
                callback(null, username === auth.username && password.toString() === auth.password);
            };
        }
    }
    /**
     * 处理类
     */
    async handlerCls() {
        const eventModules = (0, core_1.listModule)(mqtt_1.COOL_MQTT_KEY);
        for (const module of eventModules) {
            this.handlerEvent(module);
        }
    }
    /**
     * 处理事件
     * @param module
     */
    async handlerEvent(module) {
        const events = (0, core_1.getClassMetadata)(mqtt_1.COOL_MQTT_EVENT_KEY, module);
        for (const event of events) {
            const method = event.eventName ? event.eventName : event.propertyKey;
            this.serve.on(method, async (...args) => {
                const moduleInstance = await this.app
                    .getApplicationContext()
                    .getAsync(module);
                moduleInstance[event.propertyKey](...args);
            });
        }
    }
    /**
     * 发送消息
     * @param topic 话题
     * @param message 消息
     * @param other 其他配置
     */
    async publish(topic, message, other) {
        this.serve.publish({
            cmd: 'publish',
            qos: 2,
            dup: false,
            topic,
            payload: Buffer.from(message),
            retain: false,
            ...this.coolIotConfig.publish,
            ...other,
        }, error => {
            if (error) {
                this.coreLogger.error('publish fail', error);
            }
        });
    }
};
__decorate([
    (0, core_1.Config)('cool.iot'),
    __metadata("design:type", Object)
], CoolMqttServe.prototype, "coolIotConfig", void 0);
__decorate([
    (0, core_1.Logger)(),
    __metadata("design:type", Object)
], CoolMqttServe.prototype, "coreLogger", void 0);
__decorate([
    (0, core_1.App)(),
    __metadata("design:type", Object)
], CoolMqttServe.prototype, "app", void 0);
CoolMqttServe = __decorate([
    (0, core_1.Provide)(),
    (0, core_1.Scope)(core_1.ScopeEnum.Singleton)
], CoolMqttServe);
exports.CoolMqttServe = CoolMqttServe;
