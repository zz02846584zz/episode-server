"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoolFile = void 0;
const decorator_1 = require("@midwayjs/decorator");
const interface_1 = require("./interface");
const core_1 = require("@cool-midway/core");
const moment = require("moment");
const uuid_1 = require("uuid");
const path = require("path");
const fs = require("fs");
const _ = require("lodash");
const OSS = require("ali-oss");
const crypto = require("crypto");
const STS = require("qcloud-cos-sts");
const download = require("download");
const COS = require("cos-nodejs-sdk-v5");
const QINIU = require("qiniu");
const client_s3_1 = require("@aws-sdk/client-s3");
const s3_presigned_post_1 = require("@aws-sdk/s3-presigned-post");
/**
 * 文件上传
 */
let CoolFile = class CoolFile {
    async init(config) {
        const filePath = path.join(this.app.getBaseDir(), '..', 'public');
        const uploadsPath = path.join(filePath, 'uploads');
        const tempPath = path.join(filePath, 'temp');
        if (!fs.existsSync(uploadsPath)) {
            fs.mkdirSync(uploadsPath);
        }
        if (!fs.existsSync(tempPath)) {
            fs.mkdirSync(tempPath);
        }
        if (config) {
            this.config = config;
        }
        const { mode, oss, cos, qiniu, aws } = this.config;
        if (mode == interface_1.MODETYPE.CLOUD) {
            if (oss) {
                const { accessKeyId, accessKeySecret, bucket, endpoint } = oss;
                this.client = new OSS({
                    region: endpoint.split('.')[0],
                    accessKeyId,
                    accessKeySecret,
                    bucket,
                });
            }
            if (cos) {
                const { accessKeyId, accessKeySecret } = cos;
                this.client = new COS({
                    SecretId: accessKeyId,
                    SecretKey: accessKeySecret,
                });
            }
            if (qiniu) {
                const { accessKeyId, accessKeySecret } = qiniu;
                this.client = new QINIU.auth.digest.Mac(accessKeyId, accessKeySecret);
            }
            if (aws) {
                const { accessKeyId, secretAccessKey, region } = aws;
                this.client = new client_s3_1.S3Client({
                    region,
                    credentials: { accessKeyId, secretAccessKey },
                });
            }
        }
    }
    /**
     * 上传模式
     * @returns 上传模式
     */
    async getMode() {
        const { mode, oss, cos, qiniu, aws } = this.config;
        if (mode == interface_1.MODETYPE.LOCAL) {
            return {
                mode: interface_1.MODETYPE.LOCAL,
                type: interface_1.MODETYPE.LOCAL,
            };
        }
        if (oss) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.OSS,
            };
        }
        if (cos) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.COS,
            };
        }
        if (qiniu) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.QINIU,
            };
        }
        if (aws) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.AWS,
            };
        }
    }
    /**
     * 获得原始操作对象
     * @returns
     */
    getMetaFileObj() {
        return this.client;
    }
    /**
     * 下载并上传
     * @param url
     * @param fileName 文件名
     */
    async downAndUpload(url, fileName) {
        const { mode, oss, cos, qiniu, aws, domain } = this.config;
        let extend = '';
        if (url.includes('.')) {
            const urlArr = url.split('.');
            extend = '.' + urlArr[urlArr.length - 1].split('?')[0];
        }
        const data = url.includes('http')
            ? await download(url)
            : fs.readFileSync(url);
        const isCloud = mode == interface_1.MODETYPE.CLOUD;
        // 创建文件夹
        const dirPath = path.join(this.app.getBaseDir(), '..', `public/${isCloud ? 'temp' : 'uploads'}/${moment().format('YYYYMMDD')}`);
        if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath);
        }
        const uuidStr = (0, uuid_1.v1)();
        const name = `uploads/${moment().format('YYYYMMDD')}/${fileName ? fileName : uuidStr + extend}`;
        if (isCloud) {
            if (oss) {
                const ossClient = this.getMetaFileObj();
                return (await ossClient.put(name, data)).url;
            }
            if (cos) {
                const cosClient = this.getMetaFileObj();
                await cosClient.putObject({
                    Bucket: cos.bucket,
                    Region: cos.region,
                    Key: name,
                    Body: data,
                });
                return cos.publicDomain + '/' + name;
            }
            if (aws) {
                const { bucket, fields, region, publicDomain } = aws;
                const uploadParams = {
                    Bucket: bucket,
                    Key: name,
                    Body: data,
                    ACL: fields ? fields.acl : 'public-read',
                };
                const command = new client_s3_1.PutObjectCommand(uploadParams);
                await this.client.send(command);
                return publicDomain
                    ? `${publicDomain}/${name}`
                    : `https://${bucket}.s3.${region}.amazonaws.com/${name}`;
            }
            if (qiniu) {
                let uploadToken = (await this.qiniu())['token'];
                const formUploader = new QINIU.form_up.FormUploader();
                const putExtra = new QINIU.form_up.PutExtra();
                return new Promise((resolve, reject) => {
                    formUploader.put(uploadToken, name, data, putExtra, (respErr, respBody, respInfo) => {
                        if (respErr) {
                            throw respErr;
                        }
                        if (respInfo.statusCode == 200) {
                            resolve(qiniu.publicDomain + '/' + name);
                        }
                    });
                });
            }
        }
        else {
            fs.writeFileSync(`${dirPath}/${fileName ? fileName : uuidStr + extend}`, data);
            return `${domain}/public/${name}`;
        }
    }
    /**
     * 指定Key(路径)上传
     * @param filePath 文件路径
     * @param key 路径一致会覆盖源文件
     */
    async uploadWithKey(filePath, key) {
        const { mode, oss, cos, qiniu, aws } = this.config;
        const data = fs.readFileSync(filePath);
        if (mode == interface_1.MODETYPE.LOCAL) {
            fs.writeFileSync(path.join(this.app.getBaseDir(), '..', key), data);
            return this.config.domain + key;
        }
        if (mode == interface_1.MODETYPE.CLOUD) {
            if (oss) {
                const ossClient = this.getMetaFileObj();
                return (await ossClient.put(key, data)).url;
            }
            if (cos) {
                const cosClient = this.getMetaFileObj();
                await cosClient.putObject({
                    Bucket: cos.bucket,
                    Region: cos.region,
                    Key: key,
                    Body: data,
                });
                return cos.publicDomain + '/' + key;
            }
            if (qiniu) {
                let uploadToken = (await this.qiniu())['token'];
                const formUploader = new QINIU.form_up.FormUploader();
                const putExtra = new QINIU.form_up.PutExtra();
                return new Promise((resolve, reject) => {
                    formUploader.put(uploadToken, key, data, putExtra, (respErr, respBody, respInfo) => {
                        if (respErr) {
                            throw respErr;
                        }
                        if (respInfo.statusCode == 200) {
                            resolve(qiniu.publicDomain + '/' + key);
                        }
                    });
                });
            }
            if (aws) {
                const { bucket, fields, region, publicDomain } = aws;
                const uploadParams = {
                    Bucket: bucket,
                    Key: key,
                    Body: data,
                    ACL: fields ? fields.acl : 'public-read',
                };
                const command = new client_s3_1.PutObjectCommand(uploadParams);
                await this.client.send(command);
                return publicDomain
                    ? `${publicDomain}/${key}`
                    : `https://${bucket}.s3.${region}.amazonaws.com/${key}`;
            }
        }
    }
    /**
     * 上传文件
     * @param ctx
     * @param key 文件路径
     */
    async upload(ctx) {
        const { mode, oss, cos, qiniu, aws } = this.config;
        if (mode == interface_1.MODETYPE.LOCAL) {
            return await this.local(ctx);
        }
        if (mode == interface_1.MODETYPE.CLOUD) {
            if (oss) {
                return await this.oss(ctx);
            }
            if (cos) {
                return await this.cos(ctx);
            }
            if (qiniu) {
                return await this.qiniu(ctx);
            }
            if (aws) {
                return await this.aws(ctx);
            }
        }
    }
    /**
     * aws 文件上传
     * @param ctx
     */
    async aws(ctx) {
        let { bucket, fields = {}, conditions = [], expires = 3600, } = this.config.aws;
        const { key } = ctx.request.body;
        if (!conditions) {
            conditions = [{ acl: 'public-read' }, { bucket }];
        }
        if (!fields) {
            fields = {
                acl: 'public-read',
            };
        }
        const result = await (0, s3_presigned_post_1.createPresignedPost)(this.client, {
            Bucket: bucket,
            Key: key,
            Conditions: conditions,
            Fields: fields,
            Expires: expires,
        });
        return result;
    }
    /**
     * 七牛上传
     * @param ctx
     * @returns
     */
    async qiniu(ctx) {
        const { bucket, publicDomain, region, uploadUrl = `https://upload-${region}.qiniup.com/`, fileKey = 'file', } = this.config.qiniu;
        let options = {
            scope: bucket,
        };
        const putPolicy = new QINIU.rs.PutPolicy(options);
        const uploadToken = putPolicy.uploadToken(this.client);
        return new Promise((resolve, reject) => {
            resolve({
                uploadUrl,
                publicDomain,
                token: uploadToken,
                fileKey,
            });
        });
    }
    /**
     * OSS 文件上传
     * @param ctx
     */
    async oss(ctx) {
        const { accessKeyId, accessKeySecret, bucket, endpoint, expAfter = 300000, maxSize = 200 * 1024 * 1024, host, } = this.config.oss;
        const oss = {
            bucket,
            region: endpoint.split('.')[0],
            accessKeyId,
            accessKeySecret,
            expAfter,
            maxSize, // 文件最大的 size
        };
        const newHost = host ? host : `https://${bucket}.${endpoint}`;
        const expireTime = new Date().getTime() + oss.expAfter;
        const expiration = new Date(expireTime).toISOString();
        const policyString = JSON.stringify({
            expiration,
            conditions: [
                ['content-length-range', 0, oss.maxSize], // 设置上传文件的大小限制,200mb
            ],
        });
        const policy = Buffer.from(policyString).toString('base64');
        const signature = crypto
            .createHmac('sha1', oss.accessKeySecret)
            .update(policy)
            .digest('base64');
        return {
            signature,
            policy,
            host: newHost,
            OSSAccessKeyId: accessKeyId,
            success_action_status: 200,
        };
    }
    /**
     * COS 文件上传
     * @param ctx
     */
    async cos(ctx) {
        const { accessKeyId, accessKeySecret, bucket, region, publicDomain, durationSeconds = 1800, allowPrefix = '_ALLOW_DIR_/*', allowActions = [
            // 所有 action 请看文档 https://cloud.tencent.com/document/product/436/31923
            // 简单上传
            'name/cos:PutObject',
            'name/cos:PostObject',
            // 分片上传
            'name/cos:InitiateMultipartUpload',
            'name/cos:ListMultipartUploads',
            'name/cos:ListParts',
            'name/cos:UploadPart',
            'name/cos:CompleteMultipartUpload',
        ], } = this.config.cos;
        // 配置参数
        let config = {
            secretId: accessKeyId,
            secretKey: accessKeySecret,
            durationSeconds,
            bucket: bucket,
            region: region,
            // 允许操作（上传）的对象前缀，可以根据自己网站的用户登录态判断允许上传的目录，例子： user1/* 或者 * 或者a.jpg
            // 请注意当使用 * 时，可能存在安全风险，详情请参阅：https://cloud.tencent.com/document/product/436/40265
            allowPrefix,
            // 密钥的权限列表
            allowActions,
        };
        // 获取临时密钥
        let LongBucketName = config.bucket;
        let ShortBucketName = LongBucketName.substring(0, LongBucketName.lastIndexOf('-'));
        let AppId = LongBucketName.substring(LongBucketName.lastIndexOf('-') + 1);
        let policy = {
            version: '2.0',
            statement: [
                {
                    action: config.allowActions,
                    effect: 'allow',
                    resource: [
                        'qcs::cos:' +
                            config.region +
                            ':uid/' +
                            AppId +
                            ':prefix//' +
                            AppId +
                            '/' +
                            ShortBucketName +
                            '/' +
                            config.allowPrefix,
                    ],
                },
            ],
        };
        return new Promise((resolve, reject) => {
            STS.getCredential({
                secretId: config.secretId,
                secretKey: config.secretKey,
                durationSeconds: config.durationSeconds,
                policy: policy,
            }, (err, tempKeys) => {
                if (err) {
                    reject(err);
                }
                if (tempKeys) {
                    tempKeys.startTime = Math.round(Date.now() / 1000);
                }
                resolve({
                    ...tempKeys,
                    url: publicDomain,
                });
            });
        });
    }
    /**
     * 本地上传
     * @param ctx
     * @returns
     */
    async local(ctx) {
        try {
            const { key } = ctx.fields;
            if (_.isEmpty(ctx.files)) {
                throw new core_1.CoolCommException('上传文件为空');
            }
            const file = ctx.files[0];
            const extension = file.filename.split('.').pop();
            const name = moment().format('YYYYMMDD') + '/' + (key || `${(0, uuid_1.v1)()}.${extension}`);
            const target = path.join(this.app.getBaseDir(), '..', `public/uploads/${name}`);
            const dirPath = path.join(this.app.getBaseDir(), '..', `public/uploads/${moment().format('YYYYMMDD')}`);
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath);
            }
            const data = fs.readFileSync(file.data);
            fs.writeFileSync(target, data);
            return this.config.domain + '/public/uploads/' + name;
        }
        catch (err) {
            this.coreLogger.error(err);
            throw new core_1.CoolCommException('上传失败');
        }
    }
};
__decorate([
    (0, decorator_1.Config)('cool.file'),
    __metadata("design:type", Object)
], CoolFile.prototype, "config", void 0);
__decorate([
    (0, decorator_1.Logger)(),
    __metadata("design:type", Object)
], CoolFile.prototype, "coreLogger", void 0);
__decorate([
    (0, decorator_1.App)(),
    __metadata("design:type", Object)
], CoolFile.prototype, "app", void 0);
__decorate([
    (0, decorator_1.Init)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], CoolFile.prototype, "init", null);
CoolFile = __decorate([
    (0, decorator_1.Provide)(),
    (0, decorator_1.Scope)(decorator_1.ScopeEnum.Singleton)
], CoolFile);
exports.CoolFile = CoolFile;
