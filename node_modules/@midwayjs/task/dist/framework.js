"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskFramework = void 0;
const core_1 = require("@midwayjs/core");
const Bull = require("bull");
const cron_1 = require("cron");
const queueService_1 = require("./service/queueService");
let TaskFramework = class TaskFramework extends core_1.BaseFramework {
    constructor() {
        super(...arguments);
        this.queueList = [];
        this.jobList = [];
    }
    applicationInitialize(options) {
        this.app = {};
    }
    configure() {
        return this.configService.getConfiguration('task');
    }
    getFrameworkType() {
        return core_1.MidwayFrameworkType.TASK;
    }
    async run() { }
    async loadTask() {
        const legacyConfig = this.configService.getConfiguration('taskConfig');
        if (legacyConfig) {
            (0, core_1.deprecatedOutput)('[midway:task] Please use "task" replace "taskConfig"');
            this.configService.addObject({
                task: legacyConfig,
            });
        }
        const taskConfig = this.configService.getConfiguration('task');
        const modules = (0, core_1.listModule)(core_1.MODULE_TASK_KEY);
        const duplicatedCheck = new Set();
        for (const module of modules) {
            const providerName = (0, core_1.getProviderName)(module);
            if (duplicatedCheck.has(providerName)) {
                throw new core_1.MidwayCommonError(`Duplicate task class name "${providerName}"`);
            }
            else {
                duplicatedCheck.add(providerName);
            }
            const rules = (0, core_1.getClassMetadata)(core_1.MODULE_TASK_METADATA, module);
            for (const rule of rules) {
                const queue = new Bull(`${rule.name}:${rule.propertyKey}`, taskConfig);
                queue.process(async (job) => {
                    const ctx = this.app.createAnonymousContext({
                        taskInfo: {
                            type: 'Task',
                            id: job.id,
                            trigger: `${rule.name}:${rule.propertyKey}`,
                        },
                    });
                    const { logger } = ctx;
                    try {
                        logger.info('task start.');
                        const service = await ctx.requestContext.getAsync(module);
                        await core_1.Utils.toAsyncFunction(rule.value.bind(service))(job.data);
                    }
                    catch (e) {
                        logger.error(`${e.stack}`);
                        throw e;
                    }
                    logger.info('task end.');
                });
                this.queueService.saveQueueTask(`${rule.name}:${rule.propertyKey}`, queue);
                const allJobs = await queue.getRepeatableJobs();
                if (allJobs.length > 0) {
                    if (!(allJobs.length === 1 &&
                        allJobs[0].cron === rule.options.repeat.cron)) {
                        for (const item of allJobs) {
                            await queue.removeRepeatableByKey(item.key);
                        }
                    }
                }
                queue.add({}, rule.options);
                this.queueList.push(queue);
            }
        }
        duplicatedCheck.clear();
    }
    async loadLocalTask() {
        const taskConfig = this.configService.getConfiguration('task');
        const modules = (0, core_1.listModule)(core_1.MODULE_TASK_TASK_LOCAL_KEY);
        const duplicatedCheck = new Set();
        for (const module of modules) {
            const providerName = (0, core_1.getProviderName)(module);
            if (duplicatedCheck.has(providerName)) {
                throw new core_1.MidwayCommonError(`Duplicate task class name "${providerName}"`);
            }
            else {
                duplicatedCheck.add(providerName);
            }
            const rules = (0, core_1.getClassMetadata)(core_1.MODULE_TASK_TASK_LOCAL_OPTIONS, module);
            for (const rule of rules) {
                const triggerFunction = async () => {
                    const requestId = core_1.Utils.randomUUID();
                    const ctx = this.app.createAnonymousContext({
                        taskInfo: {
                            type: 'LocalTask',
                            id: requestId,
                            trigger: `${module.name}:${rule.propertyKey}`,
                        },
                    });
                    const { logger } = ctx;
                    try {
                        const service = await ctx.requestContext.getAsync(module);
                        logger.info('local task start.');
                        await core_1.Utils.toAsyncFunction(rule.value.bind(service))();
                    }
                    catch (err) {
                        logger.error(err);
                        throw err;
                    }
                    logger.info('local task end.');
                };
                const job = new cron_1.CronJob(rule.options, triggerFunction, null, true, taskConfig.defaultJobOptions.repeat.tz);
                job.start();
                this.queueService.saveLocalTask(`${module.name}:${rule.propertyKey}`, triggerFunction);
                this.jobList.push(job);
            }
        }
        duplicatedCheck.clear();
    }
    async loadQueue() {
        const modules = (0, core_1.listModule)(core_1.MODULE_TASK_QUEUE_KEY);
        const taskConfig = this.configService.getConfiguration('task');
        const config = JSON.parse(JSON.stringify(taskConfig));
        if (taskConfig && taskConfig.createClient) {
            config.createClient = taskConfig.createClient;
        }
        const concurrency = config.concurrency || 1;
        delete config.defaultJobOptions.repeat;
        for (const module of modules) {
            const rule = (0, core_1.getClassMetadata)(core_1.MODULE_TASK_QUEUE_OPTIONS, module);
            const queue = new Bull(`${rule.name}:execute`, config);
            queue.process(concurrency, async (job) => {
                const ctx = this.app.createAnonymousContext({
                    taskInfo: {
                        type: 'Queue',
                        id: job.id,
                        trigger: `${module.name}`,
                    },
                });
                const { logger } = ctx;
                try {
                    logger.info('queue process start.');
                    const service = await ctx.requestContext.getAsync(module);
                    await core_1.Utils.toAsyncFunction(service.execute.bind(service))(job.data, job);
                }
                catch (e) {
                    logger.error(`${e.stack}`);
                    throw e;
                }
                logger.info('queue process end.');
            });
            this.queueService.saveQueue(`${rule.name}:execute`, queue);
            this.queueList.push(queue);
        }
    }
    async beforeStop() {
        this.queueList.map(queue => {
            queue.close();
        });
        this.jobList.map(job => {
            job.stop();
        });
    }
};
__decorate([
    (0, core_1.Inject)(),
    __metadata("design:type", queueService_1.QueueService)
], TaskFramework.prototype, "queueService", void 0);
TaskFramework = __decorate([
    (0, core_1.Framework)()
], TaskFramework);
exports.TaskFramework = TaskFramework;
//# sourceMappingURL=framework.js.map