"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidwayLoggerContainer = void 0;
const logger_1 = require("./logger/logger");
const util = require("util");
const path_1 = require("path");
const util_1 = require("./util");
const debug = util.debuglog('midway:debug');
/**
 * 数组结构为获取当前的状态值 + 恢复状态值的方法
 */
const statusMapping = {
    disableConsole: ['isEnableConsole', 'enableConsole'],
    disableFile: ['isEnableFile', 'enableFile'],
    disableError: ['isEnableError', 'enableError'],
    updateLevel: ['getLevel', 'updateLevel'],
    updateConsoleLevel: ['getConsoleLevel', 'updateConsoleLevel'],
    updateFileLevel: ['getFileLevel', 'updateFileLevel'],
};
class MidwayLoggerContainer extends Map {
    constructor(options = {}) {
        super();
        this.loggerOriginData = {};
        this.containerLoggerData = {};
        this.aliasMap = new Map();
        this.containerOptions = options;
    }
    createLogger(name, options) {
        if (!this.has(name)) {
            debug('[logger]: Create logger "%s" with options %j', name, options);
            const logger = new logger_1.MidwayBaseLogger(Object.assign(options, this.containerOptions));
            if (options.aliasName) {
                this.aliasMap.set(options.aliasName, name);
            }
            this.syncOriginStatus(name, logger);
            this.addLogger(name, logger);
            this.set(name, logger);
            return logger;
        }
        return this.getLogger(name);
    }
    addLogger(name, logger, errorWhenReplace = true) {
        if (!errorWhenReplace || !this.has(name)) {
            // 同一个实例就不需要再添加了
            if (this.get(name) !== logger) {
                if (logger['on']) {
                    this.syncOriginStatus(name, logger);
                    logger.on('close', () => this.delete(name));
                }
                this.set(name, logger);
            }
        }
        else {
            throw new Error(`logger id ${name} has duplicate`);
        }
        return this.get(name);
    }
    getLogger(name) {
        return this.get(name);
    }
    removeLogger(name) {
        const logger = this.get(name);
        logger === null || logger === void 0 ? void 0 : logger['close']();
        this.delete(name);
        delete this.loggerOriginData[name];
    }
    get(name) {
        var _a;
        return super.get((_a = this.aliasMap.get(name)) !== null && _a !== void 0 ? _a : name);
    }
    /**
     * Closes a `Logger` instance with the specified `name` if it exists.
     * If no `name` is supplied then all Loggers are closed.
     * @param {?string} name - The id of the Logger instance to close.
     * @returns {undefined}
     */
    close(name) {
        if (name) {
            return this.removeLogger(name);
        }
        Array.from(this.keys()).forEach(key => this.removeLogger(key));
    }
    updateContainerOption(options) {
        this.containerOptions = Object.assign(this.containerOptions, options);
    }
    reset() {
        this.close();
        this.containerOptions = {};
        this.loggerOriginData = {};
    }
    setLoggerOriginData(name, logger, methodName, value) {
        if (!logger)
            return;
        this.loggerOriginData[name] = this.loggerOriginData[name] || {};
        if (logger[methodName]) {
            // store origin status
            this.loggerOriginData[name][methodName] =
                logger[statusMapping[methodName][0]].call(logger);
            // set new value
            logger[methodName].call(logger, value);
        }
    }
    syncOriginStatus(name, logger) {
        Object.keys(this.containerLoggerData).forEach(methodName => {
            this.setLoggerOriginData(name, logger, methodName, this.containerLoggerData[methodName]);
        });
    }
    disableConsole() {
        this.containerLoggerData['disableConsole'] = true;
        Array.from(this.keys()).forEach(key => {
            const logger = this.get(key);
            this.setLoggerOriginData(key, logger, 'disableConsole');
        });
    }
    disableFile() {
        this.containerLoggerData['disableFile'] = true;
        Array.from(this.keys()).forEach(key => {
            const logger = this.get(key);
            this.setLoggerOriginData(key, logger, 'disableFile');
        });
    }
    disableError() {
        this.containerLoggerData['disableError'] = true;
        Array.from(this.keys()).forEach(key => {
            const logger = this.get(key);
            this.setLoggerOriginData(key, logger, 'disableError');
        });
    }
    updateLevel(level) {
        this.containerLoggerData['updateLevel'] = level;
        Array.from(this.keys()).forEach(key => {
            const logger = this.get(key);
            this.setLoggerOriginData(key, logger, 'updateLevel', level);
        });
    }
    updateConsoleLevel(level) {
        this.containerLoggerData['updateConsoleLevel'] = level;
        Array.from(this.keys()).forEach(key => {
            const logger = this.get(key);
            this.setLoggerOriginData(key, logger, 'updateConsoleLevel', level);
        });
    }
    updateFileLevel(level) {
        this.containerLoggerData['updateFileLevel'] = level;
        Array.from(this.keys()).forEach(key => {
            const logger = this.get(key);
            this.setLoggerOriginData(key, logger, 'updateFileLevel', level);
        });
    }
    restore() {
        Array.from(Object.keys(this.loggerOriginData)).forEach(key => {
            const logger = this.get(key);
            for (const method in this.loggerOriginData[key]) {
                if (this.loggerOriginData[key][method]) {
                    // 为 true 或者有值的时候才设置
                    logger[statusMapping[method][1]].call(logger, this.loggerOriginData[key][method]);
                }
            }
        });
        this.loggerOriginData = {};
        this.containerLoggerData = {};
    }
    getDefaultMidwayLoggerConfig(appInfo) {
        var _a;
        const isDevelopment = (0, util_1.isDevelopmentEnvironment)(appInfo.env);
        const logRoot = (_a = process.env['MIDWAY_LOGGER_WRITEABLE_DIR']) !== null && _a !== void 0 ? _a : appInfo.root;
        return {
            midwayLogger: {
                default: {
                    dir: (0, path_1.join)(logRoot, 'logs', appInfo.name),
                    level: 'info',
                    consoleLevel: isDevelopment ? 'info' : 'warn',
                    auditFileDir: '.audit',
                },
                clients: {
                    coreLogger: {
                        level: isDevelopment ? 'info' : 'warn',
                        fileLogName: 'midway-core.log',
                    },
                    appLogger: {
                        fileLogName: 'midway-app.log',
                        aliasName: 'logger',
                    },
                },
            },
        };
    }
}
exports.MidwayLoggerContainer = MidwayLoggerContainer;
//# sourceMappingURL=container.js.map