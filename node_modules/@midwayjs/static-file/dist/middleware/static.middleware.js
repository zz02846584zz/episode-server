"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticMiddleware = void 0;
const core_1 = require("@midwayjs/core");
const assert = require("assert");
const staticCache = require("koa-static-cache");
const LRU = require("ylru");
const range = require("koa-range");
const error_1 = require("../error");
let StaticMiddleware = class StaticMiddleware {
    async resolve(app) {
        const dirs = Object.values(this.staticFileConfig.dirs);
        if (this.staticFileConfig.dir) {
            dirs.push(this.staticFileConfig.dir);
        }
        const prefixs = [];
        function rangeMiddleware(ctx, next) {
            // if match static file, and use range middleware.
            const isMatch = prefixs.some(p => ctx.path.startsWith(p));
            if (isMatch) {
                return range(ctx, next);
            }
            return next();
        }
        const middlewares = [rangeMiddleware];
        for (const dirObj of dirs) {
            assert(core_1.Types.isObject(dirObj) || core_1.Types.isString(dirObj), '`config.static.dir` must be `string | Array<string|object>`.');
            const newOptions = Object.assign({}, this.staticFileConfig, dirObj);
            if (newOptions.dynamic && !newOptions.files) {
                newOptions.files = new LRU(newOptions.maxFiles);
            }
            if (newOptions.prefix) {
                prefixs.push(newOptions.prefix);
            }
            // ensure directory exists
            if (!(await core_1.FileUtils.exists(newOptions.dir))) {
                throw new error_1.DirectoryNotFoundError(newOptions.dir);
            }
            this.logger.info('[midway:static] starting static serve %s -> %s', newOptions.prefix, newOptions.dir);
            middlewares.push(staticCache(newOptions));
        }
        return await this.middlewareService.compose(middlewares, app, 'staticFile');
    }
    static getName() {
        return 'staticFile';
    }
};
__decorate([
    (0, core_1.Config)('staticFile'),
    __metadata("design:type", Object)
], StaticMiddleware.prototype, "staticFileConfig", void 0);
__decorate([
    (0, core_1.Inject)(),
    __metadata("design:type", core_1.MidwayMiddlewareService)
], StaticMiddleware.prototype, "middlewareService", void 0);
__decorate([
    (0, core_1.Logger)('coreLogger'),
    __metadata("design:type", Object)
], StaticMiddleware.prototype, "logger", void 0);
StaticMiddleware = __decorate([
    (0, core_1.Middleware)()
], StaticMiddleware);
exports.StaticMiddleware = StaticMiddleware;
//# sourceMappingURL=static.middleware.js.map